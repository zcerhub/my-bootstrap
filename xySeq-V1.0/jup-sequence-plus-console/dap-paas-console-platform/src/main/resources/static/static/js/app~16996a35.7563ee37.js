(window["jsonpPaas4"]=window["jsonpPaas4"]||[]).push([["app~16996a35"],{"0376":function(e,t,n){"use strict";var o=this&&this.__extends||function(){var e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},e(t,n)};return function(t,n){if("function"!==typeof n&&null!==n)throw new TypeError("Class extends value "+String(n)+" is not a constructor or null");function o(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(o.prototype=n.prototype,new o)}}(),r=this&&this.__awaiter||function(e,t,n,o){function r(e){return e instanceof n?e:new n((function(t){t(e)}))}return new(n||(n=Promise))((function(n,a){function i(e){try{c(o.next(e))}catch(t){a(t)}}function u(e){try{c(o["throw"](e))}catch(t){a(t)}}function c(e){e.done?n(e.value):r(e.value).then(i,u)}c((o=o.apply(e,t||[])).next())}))},a=this&&this.__generator||function(e,t){var n,o,r,a,i={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return a={next:u(0),throw:u(1),return:u(2)},"function"===typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function u(e){return function(t){return c([e,t])}}function c(u){if(n)throw new TypeError("Generator is already executing.");while(a&&(a=0,u[0]&&(i=0)),i)try{if(n=1,o&&(r=2&u[0]?o["return"]:u[0]?o["throw"]||((r=o["return"])&&r.call(o),0):o.next)&&!(r=r.call(o,u[1])).done)return r;switch(o=0,r&&(u=[2&u[0],r.value]),u[0]){case 0:case 1:r=u;break;case 4:return i.label++,{value:u[1],done:!1};case 5:i.label++,o=u[1],u=[0];continue;case 7:u=i.ops.pop(),i.trys.pop();continue;default:if(r=i.trys,!(r=r.length>0&&r[r.length-1])&&(6===u[0]||2===u[0])){i=0;continue}if(3===u[0]&&(!r||u[1]>r[0]&&u[1]<r[3])){i.label=u[1];break}if(6===u[0]&&i.label<r[1]){i.label=r[1],r=u;break}if(r&&i.label<r[2]){i.label=r[2],i.ops.push(u);break}r[2]&&i.ops.pop(),i.trys.pop();continue}u=t.call(e,i)}catch(c){u=[6,c],o=0}finally{n=r=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}};Object.defineProperty(t,"__esModule",{value:!0}),t.GForceGPULayout=void 0;var i=n("5bc9"),u=n("f271"),c=n("a196"),s=n("6299"),l=n("19d2"),d=n("b3dc"),v=n("3888"),f=function(e){function t(t){var n=e.call(this)||this;return n.maxIteration=1e3,n.edgeStrength=200,n.nodeStrength=1e3,n.coulombDisScale=.005,n.damping=.9,n.maxSpeed=1e3,n.minMovement=.5,n.interval=.02,n.factor=1,n.linkDistance=1,n.gravity=10,n.workerEnabled=!1,n.nodes=[],n.edges=[],n.width=300,n.height=300,n.nodeMap={},n.nodeIdxMap={},n.updateCfg(t),n}return o(t,e),t.prototype.getDefaultCfg=function(){return{maxIteration:2e3,gravity:10,clustering:!1,clusterGravity:10}},t.prototype.execute=function(){return r(this,void 0,void 0,(function(){var e,t,n,o,r;return a(this,(function(a){switch(a.label){case 0:return e=this,t=e.nodes,t&&0!==t.length?(e.width||"undefined"===typeof window||(e.width=window.innerWidth),e.height||"undefined"===typeof window||(e.height=window.innerHeight),e.center||(e.center=[e.width/2,e.height/2]),n=e.center,1===t.length?(t[0].x=n[0],t[0].y=n[1],e.onLayoutEnd&&e.onLayoutEnd(),[2]):(o={},r={},t.forEach((function(t,n){(0,u.isNumber)(t.x)||(t.x=Math.random()*e.width),(0,u.isNumber)(t.y)||(t.y=Math.random()*e.height),o[t.id]=t,r[t.id]=n})),e.nodeMap=o,e.nodeIdxMap=r,e.nodeStrength=(0,s.proccessToFunc)(e.nodeStrength,1),e.edgeStrength=(0,s.proccessToFunc)(e.edgeStrength,1),[4,e.run()])):(e.onLayoutEnd&&e.onLayoutEnd(),[2]);case 1:return a.sent(),[2]}}))}))},t.prototype.executeWithWorker=function(e,t){var n=this,o=n.nodes,r=n.center;if(o&&0!==o.length){if(1===o.length)return o[0].x=r[0],void(o[0].y=r[1]);var a={},i={};o.forEach((function(e,t){(0,u.isNumber)(e.x)||(e.x=Math.random()*n.width),(0,u.isNumber)(e.y)||(e.y=Math.random()*n.height),a[e.id]=e,i[e.id]=t})),n.nodeMap=a,n.nodeIdxMap=i,n.nodeStrength=(0,s.proccessToFunc)(n.nodeStrength,1),n.edgeStrength=(0,s.proccessToFunc)(n.edgeStrength,1),n.run(e,t)}},t.prototype.run=function(e,t){return r(this,void 0,void 0,(function(){var n,o,i,f,p,y,g,h,x,_,D,m,I,b,w,G,S,k,z,N,C,E,T,A,L,O,M,j=this;return a(this,(function(P){switch(P.label){case 0:for(n=this,o=n.nodes,i=n.edges,f=n.maxIteration,n.width||"undefined"===typeof window||(n.width=window.innerWidth),n.height||"undefined"===typeof window||(n.height=window.innerHeight),p=o.length,n.linkDistance=(0,s.proccessToFunc)(n.linkDistance),n.edgeStrength=(0,s.proccessToFunc)(n.edgeStrength),y=(0,s.buildTextureDataWithTwoEdgeAttr)(o,i,n.linkDistance,n.edgeStrength),g=y.maxEdgePerVetex,h=y.array,n.degrees=(0,l.getDegree)(o.length,n.nodeIdxMap,i).map((function(e){return e.all})),x=[],_=[],D=[],m=[],I=[],b=[],w=[],n.getMass||(n.getMass=function(e){return n.degrees[n.nodeIdxMap[e.id]]||1}),G=n.gravity,S=n.center,o.forEach((function(e,t){x.push(n.getMass(e)),_.push(n.nodeStrength(e)),n.degrees[t]||(n.degrees[t]=0);var o=[S[0],S[1],G];if(n.getCenter){var r=n.getCenter(e,n.degrees[t]);r&&(0,u.isNumber)(r[0])&&(0,u.isNumber)(r[1])&&(0,u.isNumber)(r[2])&&(o=r)}D.push(o[0]),m.push(o[1]),I.push(o[2]),(0,u.isNumber)(e.fx)&&(0,u.isNumber)(e.fy)?(b.push(e.fx||.001),w.push(e.fy||.001)):(b.push(0),w.push(0))})),k=(0,s.arrayToTextureData)([x,n.degrees,_,b]),z=(0,s.arrayToTextureData)([D,m,I,w]),N=n.workerEnabled,C=N?c.World.create({canvas:e,engineOptions:{supportCompute:!0}}):c.World.create({engineOptions:{supportCompute:!0}}),E=n.onLayoutEnd,T=[],h.forEach((function(e){T.push(e)})),A=0;A<4;A++)T.push(0);return L=C.createKernel(d.gForceBundle).setDispatch([p,1,1]).setBinding({u_Data:h,u_damping:n.damping,u_maxSpeed:n.maxSpeed,u_minMovement:n.minMovement,u_coulombDisScale:n.coulombDisScale,u_factor:n.factor,u_NodeAttributeArray1:k,u_NodeAttributeArray2:z,MAX_EDGE_PER_VERTEX:g,VERTEX_COUNT:p,u_AveMovement:T,u_interval:n.interval}),O=C.createKernel(d.aveMovementBundle).setDispatch([1,1,1]).setBinding({u_Data:h,VERTEX_COUNT:p,u_AveMovement:[0,0,0,0]}),M=function(){return r(j,void 0,void 0,(function(){var r,i,u;return a(this,(function(a){switch(a.label){case 0:r=0,a.label=1;case 1:return r<f?[4,L.execute()]:[3,5];case 2:return a.sent(),O.setBinding({u_Data:L}),[4,O.execute()];case 3:a.sent(),i=Math.max(.02,n.interval-.002*r),L.setBinding({u_interval:i,u_AveMovement:O}),a.label=4;case 4:return r++,[3,1];case 5:return[4,L.getOutput()];case 6:return u=a.sent(),e?t.postMessage({type:v.LAYOUT_MESSAGE.GPUEND,vertexEdgeData:u}):o.forEach((function(e,t){var n=u[4*t],o=u[4*t+1];e.x=n,e.y=o})),E&&E(),[2]}}))}))},[4,M()];case 1:return P.sent(),[2]}}))}))},t.prototype.getType=function(){return"gForce-gpu"},t}(i.Base);t.GForceGPULayout=f},"077d":function(e,t,n){"use strict";var o=this&&this.__extends||function(){var e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},e(t,n)};return function(t,n){if("function"!==typeof n&&null!==n)throw new TypeError("Class extends value "+String(n)+" is not a constructor or null");function o(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(o.prototype=n.prototype,new o)}}(),r=this&&this.__awaiter||function(e,t,n,o){function r(e){return e instanceof n?e:new n((function(t){t(e)}))}return new(n||(n=Promise))((function(n,a){function i(e){try{c(o.next(e))}catch(t){a(t)}}function u(e){try{c(o["throw"](e))}catch(t){a(t)}}function c(e){e.done?n(e.value):r(e.value).then(i,u)}c((o=o.apply(e,t||[])).next())}))},a=this&&this.__generator||function(e,t){var n,o,r,a,i={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return a={next:u(0),throw:u(1),return:u(2)},"function"===typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function u(e){return function(t){return c([e,t])}}function c(u){if(n)throw new TypeError("Generator is already executing.");while(a&&(a=0,u[0]&&(i=0)),i)try{if(n=1,o&&(r=2&u[0]?o["return"]:u[0]?o["throw"]||((r=o["return"])&&r.call(o),0):o.next)&&!(r=r.call(o,u[1])).done)return r;switch(o=0,r&&(u=[2&u[0],r.value]),u[0]){case 0:case 1:r=u;break;case 4:return i.label++,{value:u[1],done:!1};case 5:i.label++,o=u[1],u=[0];continue;case 7:u=i.ops.pop(),i.trys.pop();continue;default:if(r=i.trys,!(r=r.length>0&&r[r.length-1])&&(6===u[0]||2===u[0])){i=0;continue}if(3===u[0]&&(!r||u[1]>r[0]&&u[1]<r[3])){i.label=u[1];break}if(6===u[0]&&i.label<r[1]){i.label=r[1],r=u;break}if(r&&i.label<r[2]){i.label=r[2],i.ops.push(u);break}r[2]&&i.ops.pop(),i.trys.pop();continue}u=t.call(e,i)}catch(c){u=[6,c],o=0}finally{n=r=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}};Object.defineProperty(t,"__esModule",{value:!0}),t.FruchtermanGPULayout=void 0;var i=n("5bc9"),u=n("f271"),c=n("a196"),s=n("6299"),l=n("18fc"),d=n("3888"),v=function(e){function t(t){var n=e.call(this)||this;return n.maxIteration=1e3,n.gravity=10,n.speed=1,n.clustering=!1,n.clusterField="cluster",n.clusterGravity=10,n.workerEnabled=!1,n.nodes=[],n.edges=[],n.width=300,n.height=300,n.nodeMap={},n.nodeIdxMap={},n.updateCfg(t),n}return o(t,e),t.prototype.getDefaultCfg=function(){return{maxIteration:1e3,gravity:10,speed:1,clustering:!1,clusterGravity:10}},t.prototype.execute=function(){return r(this,void 0,void 0,(function(){var e,t,n,o,r,i=this;return a(this,(function(a){switch(a.label){case 0:return e=this,t=e.nodes,t&&0!==t.length?(e.width||"undefined"===typeof window||(e.width=window.innerWidth),e.height||"undefined"===typeof window||(e.height=window.innerHeight),e.center||(e.center=[e.width/2,e.height/2]),n=e.center,1===t.length?(t[0].x=n[0],t[0].y=n[1],e.onLayoutEnd&&e.onLayoutEnd(),[2]):(o={},r={},t.forEach((function(e,t){(0,u.isNumber)(e.x)||(e.x=Math.random()*i.width),(0,u.isNumber)(e.y)||(e.y=Math.random()*i.height),o[e.id]=e,r[e.id]=t})),e.nodeMap=o,e.nodeIdxMap=r,[4,e.run()])):(e.onLayoutEnd&&e.onLayoutEnd(),[2]);case 1:return a.sent(),[2]}}))}))},t.prototype.executeWithWorker=function(e,t){return r(this,void 0,void 0,(function(){var n,o,r,i,c,s=this;return a(this,(function(a){switch(a.label){case 0:return n=this,o=n.nodes,r=n.center,o&&0!==o.length?1===o.length?(o[0].x=r[0],o[0].y=r[1],[2]):(i={},c={},o.forEach((function(e,t){(0,u.isNumber)(e.x)||(e.x=Math.random()*s.width),(0,u.isNumber)(e.y)||(e.y=Math.random()*s.height),i[e.id]=e,c[e.id]=t})),n.nodeMap=i,n.nodeIdxMap=c,[4,n.run(e,t)]):[2];case 1:return a.sent(),[2]}}))}))},t.prototype.run=function(e,t){return r(this,void 0,void 0,(function(){var n,o,i,v,f,p,y,g,h,x,_,D,m,I,b,w,G,S,k,z,N,C,E,T,A,L,O=this;return a(this,(function(M){switch(M.label){case 0:for(n=this,o=n.nodes,i=n.edges,v=n.maxIteration,f=n.center,p=n.height*n.width,y=Math.sqrt(p)/10,g=p/(o.length+1),h=Math.sqrt(g),x=n.speed,_=n.clustering,D=(0,s.attributesToTextureData)([n.clusterField],o),m=D.array,I=D.count,o.forEach((function(e,t){var n=0,o=0;(0,u.isNumber)(e.fx)&&(0,u.isNumber)(e.fy)&&(n=e.fx||.001,o=e.fy||.001),m[4*t+1]=n,m[4*t+2]=o})),b=o.length,w=(0,s.buildTextureData)(o,i),G=w.maxEdgePerVetex,S=w.array,k=n.workerEnabled,z=k?c.World.create({canvas:e,engineOptions:{supportCompute:!0}}):c.World.create({engineOptions:{supportCompute:!0}}),N=n.onLayoutEnd,C=[],E=0;E<I;E++)C.push(0,0,0,0);return T=z.createKernel(l.fruchtermanBundle).setDispatch([b,1,1]).setBinding({u_Data:S,u_K:h,u_K2:g,u_Gravity:n.gravity,u_ClusterGravity:n.clusterGravity||n.gravity||1,u_Speed:x,u_MaxDisplace:y,u_Clustering:_?1:0,u_Center:f,u_AttributeArray:m,u_ClusterCenters:C,MAX_EDGE_PER_VERTEX:G,VERTEX_COUNT:b}),_&&(A=z.createKernel(l.clusterBundle).setDispatch([I,1,1]).setBinding({u_Data:S,u_NodeAttributes:m,u_ClusterCenters:C,VERTEX_COUNT:b,CLUSTER_COUNT:I})),L=function(){return r(O,void 0,void 0,(function(){var n,r;return a(this,(function(a){switch(a.label){case 0:n=0,a.label=1;case 1:return n<v?[4,T.execute()]:[3,6];case 2:return a.sent(),_?(A.setBinding({u_Data:T}),[4,A.execute()]):[3,4];case 3:a.sent(),T.setBinding({u_ClusterCenters:A}),a.label=4;case 4:T.setBinding({u_MaxDisplace:y*=.99}),a.label=5;case 5:return n++,[3,1];case 6:return[4,T.getOutput()];case 7:return r=a.sent(),e?t.postMessage({type:d.LAYOUT_MESSAGE.GPUEND,vertexEdgeData:r}):o.forEach((function(e,t){var n=r[4*t],o=r[4*t+1];e.x=n,e.y=o})),N&&N(),[2]}}))}))},[4,L()];case 1:return M.sent(),[2]}}))}))},t.prototype.getType=function(){return"fruchterman-gpu"},t}(i.Base);t.FruchtermanGPULayout=v},"18fc":function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.clusterBundle=t.clusterCode=t.fruchtermanBundle=t.fruchtermanCode=void 0,t.fruchtermanCode="\nimport { globalInvocationID } from 'g-webgpu';\nconst MAX_EDGE_PER_VERTEX;\nconst VERTEX_COUNT;\n@numthreads(1, 1, 1)\nclass Fruchterman {\n  @in @out\n  u_Data: vec4[];\n  @in\n  u_K: float;\n  @in\n  u_K2: float;\n  \n  @in\n  u_Center: vec2;\n  @in\n  u_Gravity: float;\n  @in\n  u_ClusterGravity: float;\n  @in\n  u_Speed: float;\n  @in\n  u_MaxDisplace: float;\n  @in\n  u_Clustering: float;\n  @in\n  u_AttributeArray: vec4[];\n  @in\n  u_ClusterCenters: vec4[];\n  calcRepulsive(i: int, currentNode: vec4): vec2 {\n    let dx = 0, dy = 0;\n    for (let j = 0; j < VERTEX_COUNT; j++) {\n      if (i != j) {\n        const nextNode = this.u_Data[j];\n        const xDist = currentNode[0] - nextNode[0];\n        const yDist = currentNode[1] - nextNode[1];\n        const dist = (xDist * xDist + yDist * yDist) + 0.01;\n        let param = this.u_K2 / dist;\n        \n        if (dist > 0.0) {\n          dx += param * xDist;\n          dy += param * yDist;\n          if (xDist == 0 && yDist == 0) {\n            const sign = i < j ? 1 : -1;\n            dx += param * sign;\n            dy += param * sign;\n          }\n        }\n      }\n    }\n    return [dx, dy];\n  }\n  calcGravity(currentNode: vec4, nodeAttributes: vec4): vec2 { // \n    let dx = 0, dy = 0;\n    const vx = currentNode[0] - this.u_Center[0];\n    const vy = currentNode[1] - this.u_Center[1];\n    const gf = 0.01 * this.u_K * this.u_Gravity;\n    dx = gf * vx;\n    dy = gf * vy;\n    if (this.u_Clustering == 1) {\n      const clusterIdx = int(nodeAttributes[0]);\n      const center = this.u_ClusterCenters[clusterIdx];\n      const cvx = currentNode[0] - center[0];\n      const cvy = currentNode[1] - center[1];\n      const dist = sqrt(cvx * cvx + cvy * cvy) + 0.01;\n      const parma = this.u_K * this.u_ClusterGravity / dist;\n      dx += parma * cvx;\n      dy += parma * cvy;\n    }\n    return [dx, dy];\n  }\n  calcAttractive(i: int, currentNode: vec4): vec2 {\n    let dx = 0, dy = 0;\n    const arr_offset = int(floor(currentNode[2] + 0.5));\n    const length = int(floor(currentNode[3] + 0.5));\n    const node_buffer: vec4;\n    for (let p = 0; p < MAX_EDGE_PER_VERTEX; p++) {\n      if (p >= length) break;\n      const arr_idx = arr_offset + p;\n      // when arr_idx % 4 == 0 update currentNodedx_buffer\n      const buf_offset = arr_idx - arr_idx / 4 * 4;\n      if (p == 0 || buf_offset == 0) {\n        node_buffer = this.u_Data[int(arr_idx / 4)];\n      }\n      const float_j = buf_offset == 0 ? node_buffer[0] :\n                      buf_offset == 1 ? node_buffer[1] :\n                      buf_offset == 2 ? node_buffer[2] :\n                                        node_buffer[3];\n      const nextNode = this.u_Data[int(float_j)];\n      const xDist = currentNode[0] - nextNode[0];\n      const yDist = currentNode[1] - nextNode[1];\n      const dist = sqrt(xDist * xDist + yDist * yDist) + 0.01;\n      let attractiveF = dist / this.u_K;\n    \n      if (dist > 0.0) {\n        dx -= xDist * attractiveF;\n        dy -= yDist * attractiveF;\n        if (xDist == 0 && yDist == 0) {\n          const sign = i < int(float_j) ? 1 : -1;\n          dx -= sign * attractiveF;\n          dy -= sign * attractiveF;\n        }\n      }\n    }\n    return [dx, dy];\n  }\n  @main\n  compute() {\n    const i = globalInvocationID.x;\n    const currentNode = this.u_Data[i];\n    let dx = 0, dy = 0;\n    if (i >= VERTEX_COUNT) {\n      this.u_Data[i] = currentNode;\n      return;\n    }\n\n    // [gravity, fx, fy, 0]\n    const nodeAttributes = this.u_AttributeArray[i];\n\n    if (nodeAttributes[1] != 0 && nodeAttributes[2] != 0) {\n      // the node is fixed\n      this.u_Data[i] = [\n        nodeAttributes[1],\n        nodeAttributes[2],\n        currentNode[2],\n        currentNode[3]\n      ];\n      return;\n    }\n\n    // repulsive\n    const repulsive = this.calcRepulsive(i, currentNode);\n    dx += repulsive[0];\n    dy += repulsive[1];\n    // attractive\n    const attractive = this.calcAttractive(i, currentNode);\n    dx += attractive[0];\n    dy += attractive[1];\n    // gravity\n    const gravity = this.calcGravity(currentNode, nodeAttributes);\n    dx -= gravity[0];\n    dy -= gravity[1];\n    // speed\n    dx *= this.u_Speed;\n    dy *= this.u_Speed;\n\n    // move\n    const distLength = sqrt(dx * dx + dy * dy);\n    if (distLength > 0.0) {\n      const limitedDist = min(this.u_MaxDisplace * this.u_Speed, distLength);\n      this.u_Data[i] = [\n        currentNode[0] + dx / distLength * limitedDist,\n        currentNode[1] + dy / distLength * limitedDist,\n        currentNode[2],\n        currentNode[3]\n      ];\n    }\n  }\n}\n",t.fruchtermanBundle='{"shaders":{"WGSL":"","GLSL450":"","GLSL100":"\\n\\nfloat epsilon = 0.00001;\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\n  vec2 normAddr2D = float(address1D) * conv_const;\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\n}\\n\\nvoid barrier() {}\\n  \\n\\nuniform vec2 u_OutputTextureSize;\\nuniform int u_OutputTexelCount;\\nvarying vec2 v_TexCoord;\\n\\nbool gWebGPUDebug = false;\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\n\\n#define MAX_EDGE_PER_VERTEX __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\n\\nuniform sampler2D u_Data;\\nuniform vec2 u_DataSize;\\nvec4 getDatau_Data(vec2 address2D) {\\n  return vec4(texture2D(u_Data, address2D).rgba);\\n}\\nvec4 getDatau_Data(float address1D) {\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\n}\\nvec4 getDatau_Data(int address1D) {\\n  return getDatau_Data(float(address1D));\\n}\\nuniform float u_K;\\nuniform float u_K2;\\nuniform vec2 u_Center;\\nuniform float u_Gravity;\\nuniform float u_ClusterGravity;\\nuniform float u_Speed;\\nuniform float u_MaxDisplace;\\nuniform float u_Clustering;\\nuniform sampler2D u_AttributeArray;\\nuniform vec2 u_AttributeArraySize;\\nvec4 getDatau_AttributeArray(vec2 address2D) {\\n  return vec4(texture2D(u_AttributeArray, address2D).rgba);\\n}\\nvec4 getDatau_AttributeArray(float address1D) {\\n  return getDatau_AttributeArray(addrTranslation_1Dto2D(address1D, u_AttributeArraySize));\\n}\\nvec4 getDatau_AttributeArray(int address1D) {\\n  return getDatau_AttributeArray(float(address1D));\\n}\\nuniform sampler2D u_ClusterCenters;\\nuniform vec2 u_ClusterCentersSize;\\nvec4 getDatau_ClusterCenters(vec2 address2D) {\\n  return vec4(texture2D(u_ClusterCenters, address2D).rgba);\\n}\\nvec4 getDatau_ClusterCenters(float address1D) {\\n  return getDatau_ClusterCenters(addrTranslation_1Dto2D(address1D, u_ClusterCentersSize));\\n}\\nvec4 getDatau_ClusterCenters(int address1D) {\\n  return getDatau_ClusterCenters(float(address1D));\\n}\\nvec2 calcRepulsive(int i, vec4 currentNode) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat dx = 0.0;\\nfloat dy = 0.0;\\nfor (int j = 0; j < VERTEX_COUNT; j++) {if (i != j) {vec4 nextNode = getDatau_Data(j);\\nfloat xDist = currentNode.x - nextNode.x;\\nfloat yDist = currentNode.y - nextNode.y;\\nfloat dist = ((xDist * xDist) + (yDist * yDist)) + 0.01;\\nfloat param = u_K2 / dist;\\nif (dist > 0.0) {dx += param * xDist;\\ndy += param * yDist;\\nif ((xDist == 0.0) && (yDist == 0.0)) {float sign = (i < j) ? (1.0) : (-1.0);\\ndx += param * sign;\\ndy += param * sign;}}}}\\nreturn vec2(dx, dy);}\\nvec2 calcGravity(vec4 currentNode, vec4 nodeAttributes) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat dx = 0.0;\\nfloat dy = 0.0;\\nfloat vx = currentNode.x - u_Center.x;\\nfloat vy = currentNode.y - u_Center.y;\\nfloat gf = (0.01 * u_K) * u_Gravity;\\ndx = gf * vx;\\ndy = gf * vy;\\nif (u_Clustering == 1.0) {int clusterIdx = int(nodeAttributes.x);\\nvec4 center = getDatau_ClusterCenters(clusterIdx);\\nfloat cvx = currentNode.x - center.x;\\nfloat cvy = currentNode.y - center.y;\\nfloat dist = sqrt((cvx * cvx) + (cvy * cvy)) + 0.01;\\nfloat parma = (u_K * u_ClusterGravity) / dist;\\ndx += parma * cvx;\\ndy += parma * cvy;}\\nreturn vec2(dx, dy);}\\nvec2 calcAttractive(int i, vec4 currentNode) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat dx = 0.0;\\nfloat dy = 0.0;\\nint arr_offset = int(floor(currentNode.z + 0.5));\\nint length = int(floor(currentNode.w + 0.5));\\nvec4 node_buffer;\\nfor (int p = 0; p < MAX_EDGE_PER_VERTEX; p++) {if (p >= length) {break;}\\nint arr_idx = arr_offset + int(p);\\nint buf_offset = arr_idx - ((arr_idx / 4) * 4);\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = getDatau_Data(int(arr_idx / 4));}\\nfloat float_j = (buf_offset == 0) ? (node_buffer.x) : ((buf_offset == 1) ? (node_buffer.y) : ((buf_offset == 2) ? (node_buffer.z) : (node_buffer.w)));\\nvec4 nextNode = getDatau_Data(int(float_j));\\nfloat xDist = currentNode.x - nextNode.x;\\nfloat yDist = currentNode.y - nextNode.y;\\nfloat dist = sqrt((xDist * xDist) + (yDist * yDist)) + 0.01;\\nfloat attractiveF = dist / u_K;\\nif (dist > 0.0) {dx -= xDist * attractiveF;\\ndy -= yDist * attractiveF;\\nif ((xDist == 0.0) && (yDist == 0.0)) {float sign = (i < int(float_j)) ? (1.0) : (-1.0);\\ndx -= sign * attractiveF;\\ndy -= sign * attractiveF;}}}\\nreturn vec2(dx, dy);}\\nvoid main() {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nint i = globalInvocationID.x;\\nvec4 currentNode = getDatau_Data(i);\\nfloat dx = 0.0;\\nfloat dy = 0.0;\\nif (i >= VERTEX_COUNT) {gl_FragColor = vec4(currentNode);\\nreturn ;}\\nvec4 nodeAttributes = getDatau_AttributeArray(i);\\nif ((nodeAttributes.y != 0.0) && (nodeAttributes.z != 0.0)) {gl_FragColor = vec4(vec4(nodeAttributes.y, nodeAttributes.z, currentNode.z, currentNode.w));\\nreturn ;}\\nvec2 repulsive = calcRepulsive(i, currentNode);\\ndx += repulsive.x;\\ndy += repulsive.y;\\nvec2 attractive = calcAttractive(i, currentNode);\\ndx += attractive.x;\\ndy += attractive.y;\\nvec2 gravity = calcGravity(currentNode, nodeAttributes);\\ndx -= gravity.x;\\ndy -= gravity.y;\\ndx *= u_Speed;\\ndy *= u_Speed;\\nfloat distLength = sqrt((dx * dx) + (dy * dy));\\nif (distLength > 0.0) {float limitedDist = min(u_MaxDisplace * u_Speed, distLength);\\ngl_FragColor = vec4(vec4(currentNode.x + ((dx / distLength) * limitedDist), currentNode.y + ((dy / distLength) * limitedDist), currentNode.z, currentNode.w));}if (gWebGPUDebug) {\\n  gl_FragColor = gWebGPUDebugOutput;\\n}}\\n"},"context":{"name":"","dispatch":[1,1,1],"threadGroupSize":[1,1,1],"maxIteration":1,"defines":[{"name":"MAX_EDGE_PER_VERTEX","type":"Float","runtime":true},{"name":"VERTEX_COUNT","type":"Float","runtime":true}],"uniforms":[{"name":"u_Data","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":false,"writeonly":false,"size":[1,1]},{"name":"u_K","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_K2","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_Center","type":"vec2<f32>","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_Gravity","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_ClusterGravity","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_Speed","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_MaxDisplace","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_Clustering","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_AttributeArray","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_ClusterCenters","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]}],"globalDeclarations":[],"output":{"name":"u_Data","size":[1,1],"length":1},"needPingpong":true}}',t.clusterCode="\nimport { globalInvocationID } from 'g-webgpu';\nconst VERTEX_COUNT;\nconst CLUSTER_COUNT;\n@numthreads(1, 1, 1)\nclass CalcCenter {\n  @in\n  u_Data: vec4[];\n  @in\n  u_NodeAttributes: vec4[]; // [[clusterIdx, 0, 0, 0], ...]\n  @in @out\n  u_ClusterCenters: vec4[]; // [[cx, cy, nodeCount, clusterIdx], ...]\n  @main\n  compute() {\n    const i = globalInvocationID.x;\n    const center = this.u_ClusterCenters[i];\n    let sumx = 0;\n    let sumy = 0;\n    let count = 0;\n    for (let j = 0; j < VERTEX_COUNT; j++) {\n      const attributes = this.u_NodeAttributes[j];\n      const clusterIdx = int(attributes[0]);\n      const vertex = this.u_Data[j];\n      if (clusterIdx == i) {\n        sumx += vertex.x;\n        sumy += vertex.y;\n        count += 1;\n      }\n    }\n    this.u_ClusterCenters[i] = [\n      sumx / count,\n      sumy / count,\n      count,\n      i\n    ];\n  }\n}\n",t.clusterBundle='{"shaders":{"WGSL":"","GLSL450":"","GLSL100":"\\n\\nfloat epsilon = 0.00001;\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\n  vec2 normAddr2D = float(address1D) * conv_const;\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\n}\\n\\nvoid barrier() {}\\n  \\n\\nuniform vec2 u_OutputTextureSize;\\nuniform int u_OutputTexelCount;\\nvarying vec2 v_TexCoord;\\n\\nbool gWebGPUDebug = false;\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\n\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\n#define CLUSTER_COUNT __DefineValuePlaceholder__CLUSTER_COUNT\\n\\nuniform sampler2D u_Data;\\nuniform vec2 u_DataSize;\\nvec4 getDatau_Data(vec2 address2D) {\\n  return vec4(texture2D(u_Data, address2D).rgba);\\n}\\nvec4 getDatau_Data(float address1D) {\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\n}\\nvec4 getDatau_Data(int address1D) {\\n  return getDatau_Data(float(address1D));\\n}\\nuniform sampler2D u_NodeAttributes;\\nuniform vec2 u_NodeAttributesSize;\\nvec4 getDatau_NodeAttributes(vec2 address2D) {\\n  return vec4(texture2D(u_NodeAttributes, address2D).rgba);\\n}\\nvec4 getDatau_NodeAttributes(float address1D) {\\n  return getDatau_NodeAttributes(addrTranslation_1Dto2D(address1D, u_NodeAttributesSize));\\n}\\nvec4 getDatau_NodeAttributes(int address1D) {\\n  return getDatau_NodeAttributes(float(address1D));\\n}\\nuniform sampler2D u_ClusterCenters;\\nuniform vec2 u_ClusterCentersSize;\\nvec4 getDatau_ClusterCenters(vec2 address2D) {\\n  return vec4(texture2D(u_ClusterCenters, address2D).rgba);\\n}\\nvec4 getDatau_ClusterCenters(float address1D) {\\n  return getDatau_ClusterCenters(addrTranslation_1Dto2D(address1D, u_ClusterCentersSize));\\n}\\nvec4 getDatau_ClusterCenters(int address1D) {\\n  return getDatau_ClusterCenters(float(address1D));\\n}\\nvoid main() {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nint i = globalInvocationID.x;\\nvec4 center = getDatau_ClusterCenters(i);\\nfloat sumx = 0.0;\\nfloat sumy = 0.0;\\nfloat count = 0.0;\\nfor (int j = 0; j < VERTEX_COUNT; j++) {vec4 attributes = getDatau_NodeAttributes(j);\\nint clusterIdx = int(attributes.x);\\nvec4 vertex = getDatau_Data(j);\\nif (clusterIdx == i) {sumx += vertex.x;\\nsumy += vertex.y;\\ncount += 1.0;}}\\ngl_FragColor = vec4(vec4(sumx / count, sumy / count, count, i));if (gWebGPUDebug) {\\n  gl_FragColor = gWebGPUDebugOutput;\\n}}\\n"},"context":{"name":"","dispatch":[1,1,1],"threadGroupSize":[1,1,1],"maxIteration":1,"defines":[{"name":"VERTEX_COUNT","type":"Float","runtime":true},{"name":"CLUSTER_COUNT","type":"Float","runtime":true}],"uniforms":[{"name":"u_Data","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_NodeAttributes","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_ClusterCenters","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":false,"writeonly":false,"size":[1,1]}],"globalDeclarations":[],"output":{"name":"u_ClusterCenters","size":[1,1],"length":1},"needPingpong":true}}'},"19d2":function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getCoreNodeAndRelativeLeafNodes=t.getAvgNodePosition=t.getLayoutBBox=t.traverseTreeUp=t.scaleMatrix=t.getAdjMatrix=t.floydWarshall=t.getDegreeMap=t.getDegree=t.getEdgeTerminal=void 0;var o=n("910e"),r=n("4b03"),a=n("291d"),i=function(e,t){var n=e[t];return(0,a.isObject)(n)?n.cell:n};t.getEdgeTerminal=i;var u=function(e,n,o){for(var r=[],a=0;a<e;a++)r[a]={in:0,out:0,all:0};return o?(o.forEach((function(e){var o=(0,t.getEdgeTerminal)(e,"source"),a=(0,t.getEdgeTerminal)(e,"target");o&&r[n[o]]&&(r[n[o]].out+=1,r[n[o]].all+=1),a&&r[n[a]]&&(r[n[a]].in+=1,r[n[a]].all+=1)})),r):r};t.getDegree=u;var c=function(e,n){var o={};return e.forEach((function(e){o[e.id]={in:0,out:0,all:0}})),n?(n.forEach((function(e){var n=(0,t.getEdgeTerminal)(e,"source"),r=(0,t.getEdgeTerminal)(e,"target");n&&(o[n].out+=1,o[n].all+=1),r&&(o[r].in+=1,o[r].all+=1)})),o):o};t.getDegreeMap=c;var s=function(e){for(var t=[],n=e.length,o=0;o<n;o+=1){t[o]=[];for(var r=0;r<n;r+=1)o===r?t[o][r]=0:0!==e[o][r]&&e[o][r]?t[o][r]=e[o][r]:t[o][r]=1/0}for(var a=0;a<n;a+=1)for(o=0;o<n;o+=1)for(r=0;r<n;r+=1)t[o][r]>t[o][a]+t[a][r]&&(t[o][r]=t[o][a]+t[a][r]);return t};t.floydWarshall=s;var l=function(e,n){var o=e.nodes,r=e.edges,a=[],i={};if(!o)throw new Error("invalid nodes data!");return o&&o.forEach((function(e,t){i[e.id]=t;var n=[];a.push(n)})),null===r||void 0===r||r.forEach((function(e){var o=(0,t.getEdgeTerminal)(e,"source"),r=(0,t.getEdgeTerminal)(e,"target"),u=i[o],c=i[r];void 0!==u&&void 0!==c&&(a[u][c]=1,n||(a[c][u]=1))})),a};t.getAdjMatrix=l;var d=function(e,t){var n=[];return e.forEach((function(e){var o=[];e.forEach((function(e){o.push(e*t)})),n.push(o)})),n};t.scaleMatrix=d;var v=function(e,t){if(e&&e.children)for(var n=e.children.length-1;n>=0;n--)if(!v(e.children[n],t))return;return!!t(e)},f=function(e,t){"function"===typeof t&&v(e,t)};t.traverseTreeUp=f;var p=function(e){var t=1/0,n=1/0,a=-1/0,i=-1/0;return e.forEach((function(e){var u=e.size;(0,o.isArray)(u)?1===u.length&&(u=[u[0],u[0]]):(0,r.isNumber)(u)?u=[u,u]:(void 0===u||isNaN(u))&&(u=[30,30]);var c=[u[0]/2,u[1]/2],s=e.x-c[0],l=e.x+c[0],d=e.y-c[1],v=e.y+c[1];t>s&&(t=s),n>d&&(n=d),a<l&&(a=l),i<v&&(i=v)})),{minX:t,minY:n,maxX:a,maxY:i}};t.getLayoutBBox=p;var y=function(e){var t={x:0,y:0};e.forEach((function(e){t.x+=e.x||0,t.y+=e.y||0}));var n=e.length||1;return{x:t.x/n,y:t.y/n}};t.getAvgNodePosition=y;var g=function(e,t,n){var o,r;return"source"===e?(null===(o=null===n||void 0===n?void 0:n.find((function(e){return e.target===t.id})))||void 0===o?void 0:o.source)||{}:(null===(r=null===n||void 0===n?void 0:n.find((function(e){return e.source===t.id})))||void 0===r?void 0:r.target)||{}},h=function(e,t,n){var o=[];switch(e){case"source":o=null===n||void 0===n?void 0:n.filter((function(e){return e.source===t.id})).map((function(e){return e.target}));break;case"target":o=null===n||void 0===n?void 0:n.filter((function(e){return e.target===t.id})).map((function(e){return e.source}));break;case"both":o=null===n||void 0===n?void 0:n.filter((function(e){return e.source===t.id})).map((function(e){return e.target})).concat(null===n||void 0===n?void 0:n.filter((function(e){return e.target===t.id})).map((function(e){return e.source})));break;default:break}var r=new Set(o);return Array.from(r)},x=function(e,t,n,o,r){var a=n[t]||"",i=(null===o||void 0===o?void 0:o.filter((function(e){return e[t]===a})))||[];return"leaf"===e&&(i=i.filter((function(e){var t,n;return 0===(null===(t=r[e.id])||void 0===t?void 0:t.in)||0===(null===(n=r[e.id])||void 0===n?void 0:n.out)}))),i},_=function(e,t,n,o,r,a){var i=r[t.id],u=i.in,c=i.out,s=t,l=[];0===u?(s=g("source",t,n),l=h("both",s,n).map((function(e){return a[e]}))):0===c&&(s=g("target",t,n),l=h("both",s,n).map((function(e){return a[e]}))),l=l.filter((function(e){return r[e.id]&&(0===r[e.id].in||0===r[e.id].out)}));var d=x(e,o,t,l,r);return{coreNode:s,relativeLeafNodes:l,sameTypeLeafNodes:d}};t.getCoreNodeAndRelativeLeafNodes=_},"291d":function(e,t,n){"use strict";var o=this&&this.__assign||function(){return o=Object.assign||function(e){for(var t,n=1,o=arguments.length;n<o;n++)for(var r in t=arguments[n],t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e},o.apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.clone=t.isObject=void 0;var r=function(e){return null!==e&&"object"===typeof e};t.isObject=r;var a=function(e){if(null===e)return e;if(e instanceof Date)return new Date(e.getTime());if(e instanceof Array){var n=[];return e.forEach((function(e){n.push(e)})),n.map((function(e){return(0,t.clone)(e)}))}if("object"===typeof e&&Object.keys(e).length){var r=o({},e);return Object.keys(r).forEach((function(e){r[e]=(0,t.clone)(r[e])})),r}return e};t.clone=a},"3ddc":function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var o=n("55f6"),r=function(){function e(e){this.distances=e.distances,this.dimension=e.dimension||2,this.linkDistance=e.linkDistance}return e.prototype.layout=function(){var e=this,t=e.dimension,n=e.distances,r=e.linkDistance;try{var a=o.Matrix.mul(o.Matrix.pow(n,2),-.5),i=a.mean("row"),u=a.mean("column"),c=a.mean();a.add(c).subRowVector(i).subColumnVector(u);var s=new o.SingularValueDecomposition(a),l=o.Matrix.sqrt(s.diagonalMatrix).diagonal();return s.leftSingularVectors.toJSON().map((function(e){return o.Matrix.mul([e],[l]).toJSON()[0].splice(0,t)}))}catch(y){for(var d=[],v=0;v<n.length;v++){var f=Math.random()*r,p=Math.random()*r;d.push([f,p])}return d}},e}();t.default=r},4237:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.camelize=t.isString=void 0;var o=function(e){return"string"===typeof e};t.isString=o;var r=function(e){var t=Object.create(null);return function(n){var o=t[n];return o||(t[n]=e(n))}},a=/-(\w)/g;t.camelize=r((function(e){return e.replace(a,(function(e,t){return t?t.toUpperCase():""}))}))},"4b03":function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.toNumber=t.isNaN=t.isNumber=void 0;var o=function(e){return"number"===typeof e};t.isNumber=o;var r=function(e){return Number.isNaN(Number(e))};t.isNaN=r;var a=function(e){var n=parseFloat(e);return(0,t.isNaN)(n)?e:n};t.toNumber=a},"4da8":function(e,t,n){"use strict";var o=this&&this.__extends||function(){var e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},e(t,n)};return function(t,n){if("function"!==typeof n&&null!==n)throw new TypeError("Class extends value "+String(n)+" is not a constructor or null");function o(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(o.prototype=n.prototype,new o)}}();Object.defineProperty(t,"__esModule",{value:!0}),t.RandomLayout=void 0;var r=n("5bc9"),a=function(e){function t(t){var n=e.call(this)||this;return n.center=[0,0],n.width=300,n.height=300,n.nodes=[],n.edges=[],n.onLayoutEnd=function(){},n.updateCfg(t),n}return o(t,e),t.prototype.getDefaultCfg=function(){return{center:[0,0],width:300,height:300}},t.prototype.execute=function(){var e=this,t=e.nodes,n=.9,o=e.center;return e.width||"undefined"===typeof window||(e.width=window.innerWidth),e.height||"undefined"===typeof window||(e.height=window.innerHeight),t&&t.forEach((function(t){t.x=(Math.random()-.5)*n*e.width+o[0],t.y=(Math.random()-.5)*n*e.height+o[1]})),e.onLayoutEnd&&e.onLayoutEnd(),{nodes:t,edges:this.edges}},t.prototype.getType=function(){return"random"},t}(r.Base);t.RandomLayout=a},"4e2a":function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Layouts=t.Layout=void 0;var o=n("7049"),r=n("9a24"),a=n("4da8"),i=n("8b72"),u=n("aac1"),c=n("4d1a"),s=n("7c66"),l=n("13d2"),d=n("634b"),v=n("455a"),f=n("82cc"),p=n("fa97"),y=n("077d"),g=n("0376"),h=n("c7ea"),x=n("7d0a"),_=n("0717"),D=n("927c"),m=n("3c0e"),I=n("f271"),b=function(){function e(e){var t=(0,o.getLayoutByName)(e.type);this.layoutInstance=new t(e)}return e.prototype.layout=function(e){return this.layoutInstance.layout(e)},e.prototype.updateCfg=function(e){this.layoutInstance.updateCfg(e)},e.prototype.init=function(e){this.correctLayers(e.nodes),this.layoutInstance.init(e)},e.prototype.correctLayers=function(e){if(null===e||void 0===e?void 0:e.length){var t=1/0,n=[];if(e.forEach((function(e){(0,I.isString)(e.layer)&&(e.layer=parseInt(e.layer,10)),void 0===e.layer||isNaN(e.layer)||(n.push(e),e.layer<t&&(t=e.layer))})),t<=0){var o=Math.abs(t)+1;n.forEach((function(e){return e.layer+=o}))}}},e.prototype.execute=function(){this.layoutInstance.execute()},e.prototype.getDefaultCfg=function(){return this.layoutInstance.getDefaultCfg()},e.prototype.destroy=function(){return this.layoutInstance.destroy()},e}();t.Layout=b,t.Layouts={force:c.ForceLayout,fruchterman:p.FruchtermanLayout,forceAtlas2:_.ForceAtlas2Layout,gForce:u.GForceLayout,force2:i.Force2Layout,dagre:l.DagreLayout,dagreCompound:m.DagreCompoundLayout,circular:s.CircularLayout,radial:d.RadialLayout,concentric:v.ConcentricLayout,grid:r.GridLayout,mds:f.MDSLayout,comboForce:h.ComboForceLayout,comboCombined:x.ComboCombinedLayout,random:a.RandomLayout,"gForce-gpu":g.GForceGPULayout,"fruchterman-gpu":y.FruchtermanGPULayout,er:D.ERLayout}},5401:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var o=800,r=function(){function e(e){this.disp=[],this.positions=e.positions,this.adjMatrix=e.adjMatrix,this.focusID=e.focusID,this.radii=e.radii,this.iterations=e.iterations||10,this.height=e.height||10,this.width=e.width||10,this.speed=e.speed||100,this.gravity=e.gravity||10,this.nodeSizeFunc=e.nodeSizeFunc,this.k=e.k||5,this.strictRadial=e.strictRadial,this.nodes=e.nodes}return e.prototype.layout=function(){var e=this,t=e.positions,n=[],o=e.iterations,r=e.width/10;e.maxDisplace=r,e.disp=n;for(var a=0;a<o;a++)t.forEach((function(e,t){n[t]={x:0,y:0}})),e.getRepulsion(),e.updatePositions();return t},e.prototype.getRepulsion=function(){var e=this,t=e.positions,n=e.nodes,o=e.disp,r=e.k,a=e.radii||[];t.forEach((function(i,u){o[u]={x:0,y:0},t.forEach((function(t,c){if(u!==c&&a[u]===a[c]){var s=i[0]-t[0],l=i[1]-t[1],d=Math.sqrt(s*s+l*l);if(0===d){d=1;var v=u>c?1:-1;s=.01*v,l=.01*v}if(d<e.nodeSizeFunc(n[u])/2+e.nodeSizeFunc(n[c])/2){var f=r*r/d;o[u].x+=s/d*f,o[u].y+=l/d*f}}}))}))},e.prototype.updatePositions=function(){var e=this,t=e.positions,n=e.disp,r=e.speed,a=e.strictRadial,i=e.focusID,u=e.maxDisplace||e.width/10;a&&n.forEach((function(e,n){var o=t[n][0]-t[i][0],r=t[n][1]-t[i][1],a=Math.sqrt(o*o+r*r),u=r/a,c=-o/a,s=Math.sqrt(e.x*e.x+e.y*e.y),l=Math.acos((u*e.x+c*e.y)/s);l>Math.PI/2&&(l-=Math.PI/2,u*=-1,c*=-1);var d=Math.cos(l)*s;e.x=u*d,e.y=c*d}));var c=e.radii;t.forEach((function(e,s){if(s!==i){var l=Math.sqrt(n[s].x*n[s].x+n[s].y*n[s].y);if(l>0&&s!==i){var d=Math.min(u*(r/o),l);if(e[0]+=n[s].x/l*d,e[1]+=n[s].y/l*d,a){var v=e[0]-t[i][0],f=e[1]-t[i][1],p=Math.sqrt(v*v+f*f);v=v/p*c[s],f=f/p*c[s],e[0]=t[i][0]+v,e[1]=t[i][1]+f}}}}))},e}();t.default=r},6299:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.arrayToTextureData=t.attributesToTextureData=t.buildTextureDataWithTwoEdgeAttr=t.buildTextureData=t.proccessToFunc=void 0;var o=n("f271"),r=n("19d2"),a=function(e,t){var n;return n=e?(0,o.isNumber)(e)?function(){return e}:e:function(){return t||1},n};t.proccessToFunc=a;var i=function(e,t){var n=[],o=[],a={},i=0;for(i=0;i<e.length;i++){var u=e[i];a[u.id]=i,n.push(u.x),n.push(u.y),n.push(0),n.push(0),o.push([])}for(i=0;i<t.length;i++){var c=t[i],s=(0,r.getEdgeTerminal)(c,"source"),l=(0,r.getEdgeTerminal)(c,"target");isNaN(a[s])||isNaN(a[l])||(o[a[s]].push(a[l]),o[a[l]].push(a[s]))}var d=0;for(i=0;i<e.length;i++){var v=n.length,f=o[i],p=f.length;n[4*i+2]=v,n[4*i+3]=p,d=Math.max(d,p);for(var y=0;y<p;++y){var g=f[y];n.push(+g)}}while(n.length%4!==0)n.push(0);return{maxEdgePerVetex:d,array:new Float32Array(n)}};t.buildTextureData=i;var u=function(e,t,n,o){var a=[],i=[],u={},c=0;for(c=0;c<e.length;c++){var s=e[c];u[s.id]=c,a.push(s.x),a.push(s.y),a.push(0),a.push(0),i.push([])}for(c=0;c<t.length;c++){var l=t[c],d=(0,r.getEdgeTerminal)(l,"source"),v=(0,r.getEdgeTerminal)(l,"target");i[u[d]].push(u[v]),i[u[d]].push(n(l)),i[u[d]].push(o(l)),i[u[d]].push(0),i[u[v]].push(u[d]),i[u[v]].push(n(l)),i[u[v]].push(o(l)),i[u[v]].push(0)}var f=0;for(c=0;c<e.length;c++){var p=a.length,y=i[c],g=y.length;a[4*c+2]=p+1048576*g/4,a[4*c+3]=0,f=Math.max(f,g/4);for(var h=0;h<g;++h){var x=y[h];a.push(+x)}}while(a.length%4!==0)a.push(0);return{maxEdgePerVetex:f,array:new Float32Array(a)}};t.buildTextureDataWithTwoEdgeAttr=u;var c=function(e,t){var n=[],o=e.length,r={};return t.forEach((function(t){e.forEach((function(e,a){if(void 0===r[t[e]]&&(r[t[e]]=Object.keys(r).length),n.push(r[t[e]]),a===o-1)while(n.length%4!==0)n.push(0)}))})),{array:new Float32Array(n),count:Object.keys(r).length}};t.attributesToTextureData=c;var s=function(e){for(var t=[],n=e.length,o=e[0].length,r=function(o){e.forEach((function(e,r){if(t.push(e[o]),r===n-1)while(t.length%4!==0)t.push(0)}))},a=0;a<o;a++)r(a);return new Float32Array(t)};t.arrayToTextureData=s},"634b":function(e,t,n){"use strict";var o=this&&this.__createBinding||(Object.create?function(e,t,n,o){void 0===o&&(o=n);var r=Object.getOwnPropertyDescriptor(t,n);r&&!("get"in r?!t.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,o,r)}:function(e,t,n,o){void 0===o&&(o=n),e[o]=t[n]}),r=this&&this.__exportStar||function(e,t){for(var n in e)"default"===n||Object.prototype.hasOwnProperty.call(t,n)||o(t,e,n)};Object.defineProperty(t,"__esModule",{value:!0}),r(n("711c"),t)},7049:function(e,t,n){"use strict";var o=this&&this.__extends||function(){var e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},e(t,n)};return function(t,n){if("function"!==typeof n&&null!==n)throw new TypeError("Class extends value "+String(n)+" is not a constructor or null");function o(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(o.prototype=n.prototype,new o)}}();Object.defineProperty(t,"__esModule",{value:!0}),t.getLayoutByName=t.unRegisterLayout=t.registerLayout=void 0;var r=n("5bc9"),a=n("f271"),i=new Map,u=function(e,t){if(i.get(e),(0,a.isObject)(t)){var n=function(e){function n(n){var o,r=this;r=e.call(this)||this;var a=r,i={},u=Object.assign({},a.getDefaultCfg(),(null===(o=t.getDefaultCfg)||void 0===o?void 0:o.call(t))||{});return Object.assign(i,u,t,n),Object.keys(i).forEach((function(e){var t=i[e];a[e]=t})),r}return o(n,e),n}(r.Base);i.set(e,n)}else i.set(e,t);return i.get(e)};t.registerLayout=u;var c=function(e){i.has(e)&&i.delete(e)};t.unRegisterLayout=c;var s=function(e){return i.has(e)?i.get(e):null};t.getLayoutByName=s},"711c":function(e,t,n){"use strict";var o=this&&this.__extends||function(){var e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},e(t,n)};return function(t,n){if("function"!==typeof n&&null!==n)throw new TypeError("Class extends value "+String(n)+" is not a constructor or null");function o(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(o.prototype=n.prototype,new o)}}(),r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.RadialLayout=void 0;var a=n("f271"),i=n("5bc9"),u=r(n("3ddc")),c=r(n("5401"));function s(e){for(var t=e.length,n=e[0].length,o=[],r=0;r<t;r++){for(var a=[],i=0;i<n;i++)0!==e[r][i]?a.push(1/(e[r][i]*e[r][i])):a.push(0);o.push(a)}return o}function l(e,t){var n=-1;return e.forEach((function(e,o){e.id===t&&(n=o)})),n}function d(e,t){return Math.sqrt((e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1]))}var v=function(e){function t(t){var n=e.call(this)||this;return n.maxIteration=1e3,n.focusNode=null,n.unitRadius=null,n.linkDistance=50,n.preventOverlap=!1,n.strictRadial=!0,n.maxPreventOverlapIteration=200,n.sortStrength=10,n.nodes=[],n.edges=[],n.updateCfg(t),n}return o(t,e),t.prototype.getDefaultCfg=function(){return{maxIteration:1e3,focusNode:null,unitRadius:null,linkDistance:50,preventOverlap:!1,nodeSize:void 0,nodeSpacing:void 0,strictRadial:!0,maxPreventOverlapIteration:200,sortBy:void 0,sortStrength:10}},t.prototype.execute=function(){var e=this,t=e.nodes,n=e.edges||[];if(t&&0!==t.length){e.width||"undefined"===typeof window||(e.width=window.innerWidth),e.height||"undefined"===typeof window||(e.height=window.innerHeight),e.center||(e.center=[e.width/2,e.height/2]);var o=e.center;if(1===t.length)return t[0].x=o[0],t[0].y=o[1],void(e.onLayoutEnd&&e.onLayoutEnd());var r=e.linkDistance,i=null;if((0,a.isString)(e.focusNode)){for(var d=!1,v=0;v<t.length;v++)t[v].id===e.focusNode&&(i=t[v],e.focusNode=i,d=!0,v=t.length);d||(i=null)}else i=e.focusNode;i||(i=t[0],e.focusNode=i);var f=l(t,i.id);f<0&&(f=0),e.focusIndex=f;var p=(0,a.getAdjMatrix)({nodes:t,edges:n},!1),y=(0,a.floydWarshall)(p),g=e.maxToFocus(y,f);e.handleInfinity(y,f,g+1),e.distances=y;var h=y[f],x=e.width||500,_=e.height||500,D=x-o[0]>o[0]?o[0]:x-o[0],m=_-o[1]>o[1]?o[1]:_-o[1];0===D&&(D=x/2),0===m&&(m=_/2);var I=m>D?D:m,b=Math.max.apply(Math,h),w=[];h.forEach((function(t,n){e.unitRadius||(e.unitRadius=I/b),w[n]=t*e.unitRadius})),e.radii=w;var G=e.eIdealDisMatrix();e.eIdealDistances=G;var S=s(G);e.weights=S;var k=new u.default({linkDistance:r,distances:G}),z=k.layout();z.forEach((function(e){(0,a.isNaN)(e[0])&&(e[0]=Math.random()*r),(0,a.isNaN)(e[1])&&(e[1]=Math.random()*r)})),e.positions=z,z.forEach((function(e,n){t[n].x=e[0]+o[0],t[n].y=e[1]+o[1]})),z.forEach((function(e){e[0]-=z[f][0],e[1]-=z[f][1]})),e.run();var N,C=e.preventOverlap,E=e.nodeSize,T=e.strictRadial;if(C){var A,L=e.nodeSpacing;A=(0,a.isNumber)(L)?function(){return L}:(0,a.isFunction)(L)?L:function(){return 0},N=E?(0,a.isArray)(E)?function(e){var t=E[0]>E[1]?E[0]:E[1];return t+A(e)}:function(e){return E+A(e)}:function(e){if(e.size){if((0,a.isArray)(e.size)){var t=e.size[0]>e.size[1]?e.size[0]:e.size[1];return t+A(e)}if((0,a.isObject)(e.size)){t=e.size.width>e.size.height?e.size.width:e.size.height;return t+A(e)}return e.size+A(e)}return 10+A(e)};var O={nodes:t,nodeSizeFunc:N,adjMatrix:p,positions:z,radii:w,height:_,width:x,strictRadial:T,focusID:f,iterations:e.maxPreventOverlapIteration||200,k:z.length/4.5},M=new c.default(O);z=M.layout()}return z.forEach((function(e,n){t[n].x=e[0]+o[0],t[n].y=e[1]+o[1]})),e.onLayoutEnd&&e.onLayoutEnd(),{nodes:t,edges:n}}e.onLayoutEnd&&e.onLayoutEnd()},t.prototype.run=function(){for(var e=this,t=e.maxIteration,n=e.positions||[],o=e.weights||[],r=e.eIdealDistances||[],a=e.radii||[],i=0;i<=t;i++){var u=i/t;e.oneIteration(u,n,a,r,o)}},t.prototype.oneIteration=function(e,t,n,o,r){var a=this,i=1-e,u=a.focusIndex;t.forEach((function(a,c){var s=d(a,[0,0]),l=0===s?0:1/s;if(c!==u){var v=0,f=0,p=0;t.forEach((function(e,t){if(c!==t){var n=d(a,e),i=0===n?0:1/n,u=o[t][c];p+=r[c][t],v+=r[c][t]*(e[0]+u*(a[0]-e[0])*i),f+=r[c][t]*(e[1]+u*(a[1]-e[1])*i)}}));var y=0===n[c]?0:1/n[c];p*=i,p+=e*y*y,v*=i,v+=e*y*a[0]*l,a[0]=v/p,f*=i,f+=e*y*a[1]*l,a[1]=f/p}}))},t.prototype.eIdealDisMatrix=function(){var e=this,t=e.nodes;if(!t)return[];var n=e.distances,o=e.linkDistance,r=e.radii||[],i=e.unitRadius||50,u=[];return n&&n.forEach((function(n,c){var s=[];n.forEach((function(n,u){if(c===u)s.push(0);else if(r[c]===r[u])if("data"===e.sortBy)s.push(n*(Math.abs(c-u)*e.sortStrength)/(r[c]/i));else if(e.sortBy){var l=t[c][e.sortBy]||0,d=t[u][e.sortBy]||0;(0,a.isString)(l)&&(l=l.charCodeAt(0)),(0,a.isString)(d)&&(d=d.charCodeAt(0)),s.push(n*(Math.abs(l-d)*e.sortStrength)/(r[c]/i))}else s.push(n*o/(r[c]/i));else{var v=(o+i)/2;s.push(n*v)}})),u.push(s)})),u},t.prototype.handleInfinity=function(e,t,n){for(var o=e.length,r=0;r<o;r++)if(e[t][r]===1/0){e[t][r]=n,e[r][t]=n;for(var a=0;a<o;a++)e[r][a]!==1/0&&e[t][a]===1/0&&(e[t][a]=n+e[r][a],e[a][t]=n+e[r][a])}for(r=0;r<o;r++)if(r!==t)for(a=0;a<o;a++)if(e[r][a]===1/0){var i=Math.abs(e[t][r]-e[t][a]);i=0===i?1:i,e[r][a]=i}},t.prototype.maxToFocus=function(e,t){for(var n=0,o=0;o<e[t].length;o++)e[t][o]!==1/0&&(n=e[t][o]>n?e[t][o]:n);return n},t.prototype.getType=function(){return"radial"},t}(i.Base);t.RadialLayout=v},"82cc":function(e,t,n){"use strict";var o=this&&this.__extends||function(){var e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},e(t,n)};return function(t,n){if("function"!==typeof n&&null!==n)throw new TypeError("Class extends value "+String(n)+" is not a constructor or null");function o(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(o.prototype=n.prototype,new o)}}();Object.defineProperty(t,"__esModule",{value:!0}),t.MDSLayout=void 0;var r=n("55f6"),a=n("f271"),i=n("5bc9"),u=function(e){function t(t){var n=e.call(this)||this;return n.center=[0,0],n.linkDistance=50,n.nodes=[],n.edges=[],n.onLayoutEnd=function(){},n.updateCfg(t),n}return o(t,e),t.prototype.getDefaultCfg=function(){return{center:[0,0],linkDistance:50}},t.prototype.execute=function(){var e=this,t=e.nodes,n=e.edges,o=void 0===n?[]:n,r=e.center;if(t&&0!==t.length){if(1===t.length)return t[0].x=r[0],t[0].y=r[1],void(e.onLayoutEnd&&e.onLayoutEnd());var i=e.linkDistance,u=(0,a.getAdjMatrix)({nodes:t,edges:o},!1),c=(0,a.floydWarshall)(u);e.handleInfinity(c);var s=(0,a.scaleMatrix)(c,i);e.scaledDistances=s;var l=e.runMDS();return e.positions=l,l.forEach((function(e,n){t[n].x=e[0]+r[0],t[n].y=e[1]+r[1]})),e.onLayoutEnd&&e.onLayoutEnd(),{nodes:t,edges:o}}e.onLayoutEnd&&e.onLayoutEnd()},t.prototype.runMDS=function(){var e=this,t=2,n=e.scaledDistances,o=r.Matrix.mul(r.Matrix.pow(n,2),-.5),a=o.mean("row"),i=o.mean("column"),u=o.mean();o.add(u).subRowVector(a).subColumnVector(i);var c=new r.SingularValueDecomposition(o),s=r.Matrix.sqrt(c.diagonalMatrix).diagonal();return c.leftSingularVectors.toJSON().map((function(e){return r.Matrix.mul([e],[s]).toJSON()[0].splice(0,t)}))},t.prototype.handleInfinity=function(e){var t=-999999;e.forEach((function(e){e.forEach((function(e){e!==1/0&&t<e&&(t=e)}))})),e.forEach((function(n,o){n.forEach((function(n,r){n===1/0&&(e[o][r]=t)}))}))},t.prototype.getType=function(){return"mds"},t}(i.Base);t.MDSLayout=u},"910e":function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isArray=void 0,t.isArray=Array.isArray},"9a24":function(e,t,n){"use strict";var o=this&&this.__extends||function(){var e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},e(t,n)};return function(t,n){if("function"!==typeof n&&null!==n)throw new TypeError("Class extends value "+String(n)+" is not a constructor or null");function o(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(o.prototype=n.prototype,new o)}}();Object.defineProperty(t,"__esModule",{value:!0}),t.GridLayout=void 0;var r=n("f271"),a=n("5bc9"),i=function(e){function t(t){var n=e.call(this)||this;return n.begin=[0,0],n.preventOverlap=!0,n.preventOverlapPadding=10,n.condense=!1,n.sortBy="degree",n.nodes=[],n.edges=[],n.width=300,n.height=300,n.row=0,n.col=0,n.cellWidth=0,n.cellHeight=0,n.cellUsed={},n.id2manPos={},n.onLayoutEnd=function(){},n.updateCfg(t),n}return o(t,e),t.prototype.getDefaultCfg=function(){return{begin:[0,0],preventOverlap:!0,preventOverlapPadding:10,condense:!1,rows:void 0,cols:void 0,position:void 0,sortBy:"degree",nodeSize:30}},t.prototype.execute=function(){var e=this,t=e.nodes,n=e.edges,o=e.begin,a=t.length;if(0===a)return e.onLayoutEnd&&e.onLayoutEnd(),{nodes:t,edges:n};if(1===a)return t[0].x=o[0],t[0].y=o[1],e.onLayoutEnd&&e.onLayoutEnd(),{nodes:t,edges:n};var i=e.sortBy,u=e.width,c=e.height,s=e.condense,l=e.preventOverlapPadding,d=e.preventOverlap,v=e.nodeSpacing,f=e.nodeSize,p=[];t.forEach((function(e){p.push(e)}));var y={};if(p.forEach((function(e,t){y[e.id]=t})),("degree"===i||!(0,r.isString)(i)||void 0===p[0][i])&&(i="degree",(0,r.isNaN)(t[0].degree))){var g=(0,r.getDegree)(p.length,y,n);p.forEach((function(e,t){e.degree=g[t].all}))}p.sort((function(e,t){return t[i]-e[i]})),u||"undefined"===typeof window||(u=window.innerWidth),c||"undefined"===typeof window||(c=window.innerHeight);var h=e.rows,x=null!=e.cols?e.cols:e.columns;if(e.cells=a,null!=h&&null!=x?(e.rows=h,e.cols=x):null!=h&&null==x?(e.rows=h,e.cols=Math.ceil(e.cells/e.rows)):null==h&&null!=x?(e.cols=x,e.rows=Math.ceil(e.cells/e.cols)):(e.splits=Math.sqrt(e.cells*e.height/e.width),e.rows=Math.round(e.splits),e.cols=Math.round(e.width/e.height*e.splits)),e.rows=Math.max(e.rows,1),e.cols=Math.max(e.cols,1),e.cols*e.rows>e.cells){var _=e.small(),D=e.large();(_-1)*D>=e.cells?e.small(_-1):(D-1)*_>=e.cells&&e.large(D-1)}else while(e.cols*e.rows<e.cells){_=e.small(),D=e.large();(D+1)*_>=e.cells?e.large(D+1):e.small(_+1)}if(e.cellWidth=u/e.cols,e.cellHeight=c/e.rows,s&&(e.cellWidth=0,e.cellHeight=0),d||v){var m=(0,r.getFuncByUnknownType)(10,v),I=(0,r.getFuncByUnknownType)(30,f,!1);p.forEach((function(t){t.x&&t.y||(t.x=0,t.y=0);var n,o,a=I(t)||30;(0,r.isArray)(a)?(n=a[0],o=a[1]):(n=a,o=a);var i=void 0!==m?m(t):l,u=n+i,c=o+i;e.cellWidth=Math.max(e.cellWidth,u),e.cellHeight=Math.max(e.cellHeight,c)}))}e.cellUsed={},e.row=0,e.col=0,e.id2manPos={};for(var b=0;b<p.length;b++){var w=p[b],G=void 0;if(e.position&&(G=e.position(w)),G&&(void 0!==G.row||void 0!==G.col)){var S={row:G.row,col:G.col};if(void 0===S.col){S.col=0;while(e.used(S.row,S.col))S.col++}else if(void 0===S.row){S.row=0;while(e.used(S.row,S.col))S.row++}e.id2manPos[w.id]=S,e.use(S.row,S.col)}e.getPos(w)}return e.onLayoutEnd&&e.onLayoutEnd(),{edges:n,nodes:p}},t.prototype.small=function(e){var t,n=this,o=n.rows||5,r=n.cols||5;if(null==e)t=Math.min(o,r);else{var a=Math.min(o,r);a===n.rows?n.rows=e:n.cols=e}return t},t.prototype.large=function(e){var t,n=this,o=n.rows||5,r=n.cols||5;if(null==e)t=Math.max(o,r);else{var a=Math.max(o,r);a===n.rows?n.rows=e:n.cols=e}return t},t.prototype.used=function(e,t){var n=this;return n.cellUsed["c-".concat(e,"-").concat(t)]||!1},t.prototype.use=function(e,t){var n=this;n.cellUsed["c-".concat(e,"-").concat(t)]=!0},t.prototype.moveToNextCell=function(){var e=this,t=e.cols||5;e.col++,e.col>=t&&(e.col=0,e.row++)},t.prototype.getPos=function(e){var t,n,o=this,r=o.begin,a=o.cellWidth,i=o.cellHeight,u=o.id2manPos[e.id];if(u)t=u.col*a+a/2+r[0],n=u.row*i+i/2+r[1];else{while(o.used(o.row,o.col))o.moveToNextCell();t=o.col*a+a/2+r[0],n=o.row*i+i/2+r[1],o.use(o.row,o.col),o.moveToNextCell()}e.x=t,e.y=n},t.prototype.getType=function(){return"grid"},t}(a.Base);t.GridLayout=i},b3dc:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.aveMovementBundle=t.aveMovementCode=t.gForceBundle=t.gForceCode=void 0,t.gForceCode="\nimport { globalInvocationID } from 'g-webgpu';\n\nconst MAX_EDGE_PER_VERTEX;\nconst VERTEX_COUNT;\nconst SHIFT_20 = 1048576;\n\n@numthreads(1, 1, 1)\nclass GGForce {\n  @in @out\n  u_Data: vec4[];\n\n  @in\n  u_damping: float;\n  \n  @in\n  u_maxSpeed: float;\n\n  @in\n  u_minMovement: float;\n\n  @in\n  u_AveMovement: vec4[];\n\n  @in\n  u_coulombDisScale: float;\n\n  @in\n  u_factor: float;\n\n  @in\n  u_NodeAttributeArray1: vec4[];\n\n  @in\n  u_NodeAttributeArray2: vec4[];\n\n  @in\n  u_interval: float;\n\n  unpack_float(packedValue: float): ivec2 {\n    const packedIntValue = int(packedValue);\n    const v0 = packedIntValue / SHIFT_20;\n    return [v0, packedIntValue - v0 * SHIFT_20];\n  }\n\n  calcRepulsive(i: int, currentNode: vec4): vec2 {\n    let ax = 0, ay = 0;\n    for (let j: int = 0; j < VERTEX_COUNT; j++) {\n      if (i != j) {\n        const nextNode = this.u_Data[j];\n        const vx = currentNode[0] - nextNode[0];\n        const vy = currentNode[1] - nextNode[1];\n        const dist = sqrt(vx * vx + vy * vy) + 0.01;\n        const n_dist = (dist + 0.1) * this.u_coulombDisScale;\n        const direx = vx / dist;\n        const direy = vy / dist;\n        const attributesi = this.u_NodeAttributeArray1[i];\n        const attributesj = this.u_NodeAttributeArray1[j];\n        const massi = attributesi[0];\n        const nodeStrengthi = attributesi[2];\n        const nodeStrengthj = attributesj[2];\n        const nodeStrength = (nodeStrengthi + nodeStrengthj) / 2;\n        // const param = nodeStrength * this.u_factor / (n_dist * n_dist * massi);\n        const param = nodeStrength * this.u_factor / (n_dist * n_dist);\n        ax += direx * param;\n        ay += direy * param;\n      }\n    }\n    return [ax, ay];\n  }\n\n  calcGravity(i: int, currentNode: vec4, attributes2: vec4): vec2 {\n    // note: attributes2 = [centerX, centerY, gravity, 0]\n\n    const vx = currentNode[0] - attributes2[0];\n    const vy = currentNode[1] - attributes2[1];\n    \n    const ax = vx * attributes2[2];\n    const ay = vy * attributes2[2];\n    \n    return [ax, ay];\n  }\n\n  calcAttractive(i: int, currentNode: vec4, attributes1: vec4): vec2 {\n    // note: attributes1 = [mass, degree, nodeSterngth, 0]\n\n    const mass = attributes1[0];\n    let ax = 0, ay = 0;\n    // const arr_offset = int(floor(currentNode[2] + 0.5));\n    // const length = int(floor(currentNode[3] + 0.5));\n\n    const compressed = this.unpack_float(currentNode[2]);\n    const length = compressed[0];\n    const arr_offset = compressed[1];\n\n    const node_buffer: vec4;\n    for (let p: int = 0; p < MAX_EDGE_PER_VERTEX; p++) {\n      if (p >= length) break;\n      const arr_idx = arr_offset + 4 * p; // i 节点的第 p 条边开始的小格子位置\n      const buf_offset = arr_idx - arr_idx / 4 * 4;\n      if (p == 0 || buf_offset == 0) {\n        node_buffer = this.u_Data[int(arr_idx / 4)]; // 大格子，大格子位置=小个子位置 / 4，\n      }\n\n      let float_j: float = node_buffer[0];\n\n      const nextNode = this.u_Data[int(float_j)];\n      const vx = nextNode[0] - currentNode[0];\n      const vy = nextNode[1] - currentNode[1];\n      const dist = sqrt(vx * vx + vy * vy) + 0.01;\n      const direx = vx / dist;\n      const direy = vy / dist;\n      const edgeLength = node_buffer[1];\n      const edgeStrength = node_buffer[2];\n      const diff: float = edgeLength - dist;//edgeLength\n      // const param = diff * this.u_stiffness / mass; //\n      const param = diff * edgeStrength / mass; // \n      ax -= direx * param;\n      ay -= direy * param;\n    }\n    return [ax, ay];\n  }\n\n  @main\n  compute() {\n    const i = globalInvocationID.x;\n    const currentNode = this.u_Data[i];\n    const movement = u_AveMovement[0];\n    let ax = 0, ay = 0;\n\n    if (i >= VERTEX_COUNT || movement.x < u_minMovement) {\n      this.u_Data[i] = currentNode;\n      return;\n    }\n\n    // 每个节点属性占两个数组中各一格\n    // [mass, degree, nodeStrength, fx]\n    const nodeAttributes1 = this.u_NodeAttributeArray1[i];\n    // [centerX, centerY, centerGravity, fy]\n    const nodeAttributes2 = this.u_NodeAttributeArray2[i];\n\n    // repulsive\n    const repulsive = this.calcRepulsive(i, currentNode);\n    ax += repulsive[0];\n    ay += repulsive[1];\n\n    // attractive\n    const attractive = this.calcAttractive(i, currentNode, nodeAttributes1);\n    ax += attractive[0];\n    ay += attractive[1];\n\n    // gravity\n    const gravity = this.calcGravity(i, currentNode, nodeAttributes2);\n    ax -= gravity[0];\n    ay -= gravity[1];\n\n    // speed\n    const param = this.u_interval * this.u_damping;\n    let vx = ax * param;\n    let vy = ay * param;\n    const vlength = sqrt(vx * vx + vy * vy) + 0.0001;\n    if (vlength > this.u_maxSpeed) {\n      const param2 = this.u_maxSpeed / vlength;\n      vx = param2 * vx;\n      vy = param2 * vy;\n    }\n\n    // move\n    if (nodeAttributes1[3] != 0 && nodeAttributes2[3] != 0) {\n      this.u_Data[i] = [\n        nodeAttributes1[3],\n        nodeAttributes2[3],\n        currentNode[2],\n        0\n      ];\n    } else {\n      const distx = vx * this.u_interval;\n      const disty = vy * this.u_interval;\n      const distLength = sqrt(distx * distx + disty * disty);\n      this.u_Data[i] = [\n        currentNode[0] + distx,\n        currentNode[1] + disty,\n        currentNode[2],\n        distLength\n      ];\n    }\n    \n    // the avarage move distance\n    // need to share memory\n    \n  }\n}\n",t.gForceBundle='{"shaders":{"WGSL":"","GLSL450":"","GLSL100":"\\n\\nfloat epsilon = 0.00001;\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\n  vec2 normAddr2D = float(address1D) * conv_const;\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\n}\\n\\nvoid barrier() {}\\n  \\n\\nuniform vec2 u_OutputTextureSize;\\nuniform int u_OutputTexelCount;\\nvarying vec2 v_TexCoord;\\n\\nbool gWebGPUDebug = false;\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\n\\n#define MAX_EDGE_PER_VERTEX __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\n#define SHIFT_20 1048576.0\\n\\nuniform sampler2D u_Data;\\nuniform vec2 u_DataSize;\\nvec4 getDatau_Data(vec2 address2D) {\\n  return vec4(texture2D(u_Data, address2D).rgba);\\n}\\nvec4 getDatau_Data(float address1D) {\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\n}\\nvec4 getDatau_Data(int address1D) {\\n  return getDatau_Data(float(address1D));\\n}\\nuniform float u_damping;\\nuniform float u_maxSpeed;\\nuniform float u_minMovement;\\nuniform sampler2D u_AveMovement;\\nuniform vec2 u_AveMovementSize;\\nvec4 getDatau_AveMovement(vec2 address2D) {\\n  return vec4(texture2D(u_AveMovement, address2D).rgba);\\n}\\nvec4 getDatau_AveMovement(float address1D) {\\n  return getDatau_AveMovement(addrTranslation_1Dto2D(address1D, u_AveMovementSize));\\n}\\nvec4 getDatau_AveMovement(int address1D) {\\n  return getDatau_AveMovement(float(address1D));\\n}\\nuniform float u_coulombDisScale;\\nuniform float u_factor;\\nuniform sampler2D u_NodeAttributeArray1;\\nuniform vec2 u_NodeAttributeArray1Size;\\nvec4 getDatau_NodeAttributeArray1(vec2 address2D) {\\n  return vec4(texture2D(u_NodeAttributeArray1, address2D).rgba);\\n}\\nvec4 getDatau_NodeAttributeArray1(float address1D) {\\n  return getDatau_NodeAttributeArray1(addrTranslation_1Dto2D(address1D, u_NodeAttributeArray1Size));\\n}\\nvec4 getDatau_NodeAttributeArray1(int address1D) {\\n  return getDatau_NodeAttributeArray1(float(address1D));\\n}\\nuniform sampler2D u_NodeAttributeArray2;\\nuniform vec2 u_NodeAttributeArray2Size;\\nvec4 getDatau_NodeAttributeArray2(vec2 address2D) {\\n  return vec4(texture2D(u_NodeAttributeArray2, address2D).rgba);\\n}\\nvec4 getDatau_NodeAttributeArray2(float address1D) {\\n  return getDatau_NodeAttributeArray2(addrTranslation_1Dto2D(address1D, u_NodeAttributeArray2Size));\\n}\\nvec4 getDatau_NodeAttributeArray2(int address1D) {\\n  return getDatau_NodeAttributeArray2(float(address1D));\\n}\\nuniform float u_interval;\\nivec2 unpack_float(float packedValue) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nint packedIntValue = int(packedValue);\\nint v0 = packedIntValue / int(SHIFT_20);\\nreturn ivec2(v0, packedIntValue - (v0 * int(SHIFT_20)));}\\nvec2 calcRepulsive(int i, vec4 currentNode) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat ax = 0.0;\\nfloat ay = 0.0;\\nfor (int j = 0; j < VERTEX_COUNT; j++) {if (i != j) {vec4 nextNode = getDatau_Data(j);\\nfloat vx = currentNode.x - nextNode.x;\\nfloat vy = currentNode.y - nextNode.y;\\nfloat dist = sqrt((vx * vx) + (vy * vy)) + 0.01;\\nfloat n_dist = (dist + 0.1) * u_coulombDisScale;\\nfloat direx = vx / dist;\\nfloat direy = vy / dist;\\nvec4 attributesi = getDatau_NodeAttributeArray1(i);\\nvec4 attributesj = getDatau_NodeAttributeArray1(j);\\nfloat massi = attributesi.x;\\nfloat nodeStrengthi = attributesi.z;\\nfloat nodeStrengthj = attributesj.z;\\nfloat nodeStrength = (nodeStrengthi + nodeStrengthj) / 2.0;\\nfloat param = (nodeStrength * u_factor) / (n_dist * n_dist);\\nax += direx * param;\\nay += direy * param;}}\\nreturn vec2(ax, ay);}\\nvec2 calcGravity(int i, vec4 currentNode, vec4 attributes2) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat vx = currentNode.x - attributes2.x;\\nfloat vy = currentNode.y - attributes2.y;\\nfloat ax = vx * attributes2.z;\\nfloat ay = vy * attributes2.z;\\nreturn vec2(ax, ay);}\\nvec2 calcAttractive(int i, vec4 currentNode, vec4 attributes1) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat mass = attributes1.x;\\nfloat ax = 0.0;\\nfloat ay = 0.0;\\nivec2 compressed = unpack_float(currentNode.z);\\nint length = compressed.x;\\nint arr_offset = compressed.y;\\nvec4 node_buffer;\\nfor (int p = 0; p < MAX_EDGE_PER_VERTEX; p++) {if (p >= length) {break;}\\nint arr_idx = arr_offset + (4 * p);\\nint buf_offset = arr_idx - ((arr_idx / 4) * 4);\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = getDatau_Data(int(arr_idx / 4));}\\nfloat float_j = node_buffer.x;\\nvec4 nextNode = getDatau_Data(int(float_j));\\nfloat vx = nextNode.x - currentNode.x;\\nfloat vy = nextNode.y - currentNode.y;\\nfloat dist = sqrt((vx * vx) + (vy * vy)) + 0.01;\\nfloat direx = vx / dist;\\nfloat direy = vy / dist;\\nfloat edgeLength = node_buffer.y;\\nfloat edgeStrength = node_buffer.z;\\nfloat diff = edgeLength - dist;\\nfloat param = (diff * edgeStrength) / mass;\\nax -= direx * param;\\nay -= direy * param;}\\nreturn vec2(ax, ay);}\\nvoid main() {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nint i = globalInvocationID.x;\\nvec4 currentNode = getDatau_Data(i);\\nvec4 movement = getDatau_AveMovement(0.0);\\nfloat ax = 0.0;\\nfloat ay = 0.0;\\nif ((i >= VERTEX_COUNT) || (movement.x < u_minMovement)) {gl_FragColor = vec4(currentNode);\\nreturn ;}\\nvec4 nodeAttributes1 = getDatau_NodeAttributeArray1(i);\\nvec4 nodeAttributes2 = getDatau_NodeAttributeArray2(i);\\nvec2 repulsive = calcRepulsive(i, currentNode);\\nax += repulsive.x;\\nay += repulsive.y;\\nvec2 attractive = calcAttractive(i, currentNode, nodeAttributes1);\\nax += attractive.x;\\nay += attractive.y;\\nvec2 gravity = calcGravity(i, currentNode, nodeAttributes2);\\nax -= gravity.x;\\nay -= gravity.y;\\nfloat param = u_interval * u_damping;\\nfloat vx = ax * param;\\nfloat vy = ay * param;\\nfloat vlength = sqrt((vx * vx) + (vy * vy)) + 0.0001;\\nif (vlength > u_maxSpeed) {float param2 = u_maxSpeed / vlength;\\nvx = param2 * vx;\\nvy = param2 * vy;}\\nif ((nodeAttributes1.w != 0.0) && (nodeAttributes2.w != 0.0)) {gl_FragColor = vec4(vec4(nodeAttributes1.w, nodeAttributes2.w, currentNode.z, 0.0));}else {float distx = vx * u_interval;\\nfloat disty = vy * u_interval;\\nfloat distLength = sqrt((distx * distx) + (disty * disty));\\ngl_FragColor = vec4(vec4(currentNode.x + distx, currentNode.y + disty, currentNode.z, distLength));}if (gWebGPUDebug) {\\n  gl_FragColor = gWebGPUDebugOutput;\\n}}\\n"},"context":{"name":"","dispatch":[1,1,1],"threadGroupSize":[1,1,1],"maxIteration":1,"defines":[{"name":"MAX_EDGE_PER_VERTEX","type":"Float","runtime":true},{"name":"VERTEX_COUNT","type":"Float","runtime":true},{"name":"SHIFT_20","type":"Float","value":1048576,"runtime":false}],"uniforms":[{"name":"u_Data","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":false,"writeonly":false,"size":[1,1]},{"name":"u_damping","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_maxSpeed","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_minMovement","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_AveMovement","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_coulombDisScale","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_factor","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_NodeAttributeArray1","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_NodeAttributeArray2","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_interval","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]}],"globalDeclarations":[],"output":{"name":"u_Data","size":[1,1],"length":1},"needPingpong":true}}',t.aveMovementCode="\nconst VERTEX_COUNT;\n@numthreads(1, 1, 1)\nclass CalcAveMovement {\n  @in\n  u_Data: vec4[];\n  @in\n  u_iter: float;\n  @in @out\n  u_AveMovement: vec4[];\n  @main\n  compute() {\n    let movement = 0;\n    for (let j: int = 0; j < VERTEX_COUNT; j++) {\n      const vertex = this.u_Data[j];\n      movement += vertex[3];\n    }\n    movement = movement / float(VERTEX_COUNT);\n    this.u_AveMovement[0] = [movement, 0, 0, 0];\n  }\n}\n",t.aveMovementBundle='{"shaders":{"WGSL":"","GLSL450":"","GLSL100":"\\n\\nfloat epsilon = 0.00001;\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\n  vec2 normAddr2D = float(address1D) * conv_const;\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\n}\\n\\nvoid barrier() {}\\n  \\n\\nuniform vec2 u_OutputTextureSize;\\nuniform int u_OutputTexelCount;\\nvarying vec2 v_TexCoord;\\n\\nbool gWebGPUDebug = false;\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\n\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\n\\nuniform sampler2D u_Data;\\nuniform vec2 u_DataSize;\\nvec4 getDatau_Data(vec2 address2D) {\\n  return vec4(texture2D(u_Data, address2D).rgba);\\n}\\nvec4 getDatau_Data(float address1D) {\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\n}\\nvec4 getDatau_Data(int address1D) {\\n  return getDatau_Data(float(address1D));\\n}\\nuniform float u_iter;\\nuniform sampler2D u_AveMovement;\\nuniform vec2 u_AveMovementSize;\\nvec4 getDatau_AveMovement(vec2 address2D) {\\n  return vec4(texture2D(u_AveMovement, address2D).rgba);\\n}\\nvec4 getDatau_AveMovement(float address1D) {\\n  return getDatau_AveMovement(addrTranslation_1Dto2D(address1D, u_AveMovementSize));\\n}\\nvec4 getDatau_AveMovement(int address1D) {\\n  return getDatau_AveMovement(float(address1D));\\n}\\nvoid main() {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat movement = 0.0;\\nfor (int j = 0; j < VERTEX_COUNT; j++) {vec4 vertex = getDatau_Data(j);\\nmovement += vertex.w;}\\nmovement = movement / float(VERTEX_COUNT);\\ngl_FragColor = vec4(vec4(movement, 0.0, 0.0, 0.0));if (gWebGPUDebug) {\\n  gl_FragColor = gWebGPUDebugOutput;\\n}}\\n"},"context":{"name":"","dispatch":[1,1,1],"threadGroupSize":[1,1,1],"maxIteration":1,"defines":[{"name":"VERTEX_COUNT","type":"Float","runtime":true}],"uniforms":[{"name":"u_Data","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_iter","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_AveMovement","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":false,"writeonly":false,"size":[1,1]}],"globalDeclarations":[],"output":{"name":"u_AveMovement","size":[1,1],"length":1},"needPingpong":true}}'},b3ea:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0})},ccec:function(e,t,n){"use strict";var o=this&&this.__createBinding||(Object.create?function(e,t,n,o){void 0===o&&(o=n);var r=Object.getOwnPropertyDescriptor(t,n);r&&!("get"in r?!t.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,o,r)}:function(e,t,n,o){void 0===o&&(o=n),e[o]=t[n]}),r=this&&this.__exportStar||function(e,t){for(var n in e)"default"===n||Object.prototype.hasOwnProperty.call(t,n)||o(t,e,n)};Object.defineProperty(t,"__esModule",{value:!0}),t.ERLayout=t.ForceAtlas2Layout=t.ComboCombinedLayout=t.ComboForceLayout=t.GForceGPULayout=t.FruchtermanGPULayout=t.FruchtermanLayout=t.MDSLayout=t.ConcentricLayout=t.RadialLayout=t.DagreCompoundLayout=t.DagreLayout=t.CircularLayout=t.ForceLayout=t.Force2Layout=t.GForceLayout=t.RandomLayout=t.GridLayout=t.Layouts=t.Layout=void 0;var a=n("9a24");Object.defineProperty(t,"GridLayout",{enumerable:!0,get:function(){return a.GridLayout}});var i=n("4da8");Object.defineProperty(t,"RandomLayout",{enumerable:!0,get:function(){return i.RandomLayout}});var u=n("aac1");Object.defineProperty(t,"GForceLayout",{enumerable:!0,get:function(){return u.GForceLayout}});var c=n("8b72");Object.defineProperty(t,"Force2Layout",{enumerable:!0,get:function(){return c.Force2Layout}});var s=n("4d1a");Object.defineProperty(t,"ForceLayout",{enumerable:!0,get:function(){return s.ForceLayout}});var l=n("7c66");Object.defineProperty(t,"CircularLayout",{enumerable:!0,get:function(){return l.CircularLayout}});var d=n("13d2");Object.defineProperty(t,"DagreLayout",{enumerable:!0,get:function(){return d.DagreLayout}});var v=n("3c0e");Object.defineProperty(t,"DagreCompoundLayout",{enumerable:!0,get:function(){return v.DagreCompoundLayout}});var f=n("634b");Object.defineProperty(t,"RadialLayout",{enumerable:!0,get:function(){return f.RadialLayout}});var p=n("455a");Object.defineProperty(t,"ConcentricLayout",{enumerable:!0,get:function(){return p.ConcentricLayout}});var y=n("82cc");Object.defineProperty(t,"MDSLayout",{enumerable:!0,get:function(){return y.MDSLayout}});var g=n("fa97");Object.defineProperty(t,"FruchtermanLayout",{enumerable:!0,get:function(){return g.FruchtermanLayout}});var h=n("077d");Object.defineProperty(t,"FruchtermanGPULayout",{enumerable:!0,get:function(){return h.FruchtermanGPULayout}});var x=n("0376");Object.defineProperty(t,"GForceGPULayout",{enumerable:!0,get:function(){return x.GForceGPULayout}});var _=n("c7ea");Object.defineProperty(t,"ComboForceLayout",{enumerable:!0,get:function(){return _.ComboForceLayout}});var D=n("7d0a");Object.defineProperty(t,"ComboCombinedLayout",{enumerable:!0,get:function(){return D.ComboCombinedLayout}});var m=n("0717");Object.defineProperty(t,"ForceAtlas2Layout",{enumerable:!0,get:function(){return m.ForceAtlas2Layout}});var I=n("927c");Object.defineProperty(t,"ERLayout",{enumerable:!0,get:function(){return I.ERLayout}});var b=n("4e2a");Object.defineProperty(t,"Layout",{enumerable:!0,get:function(){return b.Layout}}),Object.defineProperty(t,"Layouts",{enumerable:!0,get:function(){return b.Layouts}}),r(n("b3ea"),t)},dccd:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getFuncByUnknownType=t.getFunc=t.isFunction=void 0;var o=n("f271"),r=n("4b03"),a=function(e){return"function"===typeof e};t.isFunction=a;var i=function(e,t,n){var o;return o=n||((0,r.isNumber)(e)?function(){return e}:function(){return t}),o};t.getFunc=i;var u=function(e,n,a){return void 0===a&&(a=!0),n||0===n?(0,t.isFunction)(n)?n:(0,r.isNumber)(n)?function(){return n}:(0,o.isArray)(n)?function(){if(a){var t=Math.max.apply(Math,n);return isNaN(t)?e:t}return n}:(0,o.isObject)(n)?function(){if(a){var t=Math.max(n.width,n.height);return isNaN(t)?e:t}return[n.width,n.height]}:function(){return e}:function(t){return t.size?(0,o.isArray)(t.size)?t.size[0]>t.size[1]?t.size[0]:t.size[1]:(0,o.isObject)(t.size)?t.size.width>t.size.height?t.size.width:t.size.height:t.size:e}};t.getFuncByUnknownType=u},f271:function(e,t,n){"use strict";var o=this&&this.__createBinding||(Object.create?function(e,t,n,o){void 0===o&&(o=n);var r=Object.getOwnPropertyDescriptor(t,n);r&&!("get"in r?!t.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,o,r)}:function(e,t,n,o){void 0===o&&(o=n),e[o]=t[n]}),r=this&&this.__exportStar||function(e,t){for(var n in e)"default"===n||Object.prototype.hasOwnProperty.call(t,n)||o(t,e,n)};Object.defineProperty(t,"__esModule",{value:!0}),r(n("4237"),t),r(n("910e"),t),r(n("4b03"),t),r(n("19d2"),t),r(n("291d"),t),r(n("dccd"),t)}}]);